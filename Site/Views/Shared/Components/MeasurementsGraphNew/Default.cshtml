@using System.Globalization
@using Microsoft.AspNetCore.Html
@using Site.Pages
@model Site.ViewComponents.MeasurementsGraphNewModel

@{
    var uniqueId = Guid.NewGuid().ToString("N");

@*
    const double autoScale = 100.0; // mm

    string yAxisSuffix;

    var measurements = Model.Measurements;
    var accountSensor = Model.AccountSensorEntity;

    IEnumerable<double?>? maxDistance, minDistance, meanDistance;
    double? scale, absoluteMin, absoluteMax;

    if (accountSensor is not { DistanceMmEmpty: not null })
    {
        maxDistance = null;
        minDistance = null;
        meanDistance = null;
        scale = null;
        absoluteMin = null;
        absoluteMax = null;
        yAxisSuffix = "";
    }
    else if (!accountSensor.DistanceMmFull.HasValue)
    {
        maxDistance = measurements.Select(m => (double?)m.MaxDistance.HeightMm);
        minDistance = measurements.Select(m => (double?)m.MinDistance.HeightMm);
        meanDistance = measurements.Select(m => (double?)m.MeanDistance.HeightMm);
        scale = autoScale;
        if (accountSensor.NoMinMaxConstraints)
            absoluteMin = null;
        else
            absoluteMin = 0.0;
        absoluteMax = null;
        yAxisSuffix = " mm";
    }
    else if (!accountSensor.CapacityL.HasValue)
    {
        maxDistance = measurements.Select(m => m.MaxDistance.LevelFraction * 100.0);
        minDistance = measurements.Select(m => m.MinDistance.LevelFraction * 100.0);
        meanDistance = measurements.Select(m => m.MeanDistance.LevelFraction * 100.0);
        scale = (autoScale / (accountSensor.DistanceMmEmpty - accountSensor.DistanceMmFull)) * 100.0;
        if (accountSensor.NoMinMaxConstraints)
        {
            absoluteMin = null;
            absoluteMax = null;
        }
        else
        {
            absoluteMin = 0.0;
            absoluteMax = 100.0;
        }
        yAxisSuffix = " %";
    }
    else
    {
        maxDistance = measurements.Select(m => m.MaxDistance.WaterL);
        minDistance = measurements.Select(m => m.MinDistance.WaterL);
        meanDistance = measurements.Select(m => m.MeanDistance.WaterL);
        scale = (autoScale / (accountSensor.DistanceMmEmpty - accountSensor.DistanceMmFull)) * accountSensor.CapacityL;
        if (accountSensor.NoMinMaxConstraints)
        {
            absoluteMin = null;
            absoluteMax = null;
        }
        else
        {
            absoluteMin = 0.0;
            absoluteMax = accountSensor.CapacityL;
        }
        yAxisSuffix = " L";
    }

    var min = minDistance?.Min();
    var max = maxDistance?.Max();
    if (min.HasValue && max.HasValue && scale.HasValue)
    {
        if (max.Value - min.Value < scale)
        {
            double basis = (max.Value + min.Value) / 2.0;
            max = Math.Round(basis + scale.Value / 2.0, 0);
            min = Math.Round(basis - scale.Value / 2.0, 0);
        }

        if (absoluteMin.HasValue && min.Value < absoluteMin.Value)
        {
            min = absoluteMin;
            if (min + scale > max)
                max = min + scale;
        }
        
        if (absoluteMax.HasValue && max.Value > absoluteMax.Value)
        {
            max = absoluteMax;
            if (max - scale < min)
                min = max - scale;
        }
    }
*@
}

<div id="chart-container-@uniqueId" style="height: 40vh; width: 100%; touch-action: none;"></div>
<script src="https://fastly.jsdelivr.net/npm/echarts@5.5.1/dist/echarts.min.js"></script>

@if (Model.AccountSensorEntity != null)
{
    <script defer>
var getJSON = function(url, callback) {
    var xhr = new XMLHttpRequest();
    xhr.open('GET', url, true);
    xhr.responseType = 'json';
    xhr.onload = function() {
      var status = xhr.status;
      if (status === 200) {
        callback(null, xhr.response);
      } else {
        callback(status, xhr.response);
      }
    };
    xhr.send();
};

getJSON('/api@(Model.AccountSensorEntity.RestPath)/m?fromDays=@(Model.FromDays)', 
    function(err, data2) {

    data2 = data2.map( el => [el.timeStamp, el.waterL]);

    var zoomEnd = new Date();
    //var zoomStart = new Date((new Date(data2[data2.length - 1][0])).getTime() - 21 * 24 * 60 * 60 * 1000);
    var zoomStart = new Date(zoomEnd.getTime() - 21 * 24 * 60 * 60 * 1000);

    var dom = document.getElementById('chart-container-@uniqueId');
    var myChart = echarts.init(dom, null, {
    renderer: 'canvas',
    useDirtyRect: false
    });
    var app = {};

    var option = {
    tooltip: {
        trigger: 'axis',
        confine: true,
        position: function (pt) {
            return [pt[0], '10%'];
        }
    },
    title: {
        left: 'center',
        text: 'Liter'
    },
    toolbox: {
        feature: {
        dataZoom: {
            yAxisIndex: 'none'
        },
        restore: {},
        saveAsImage: {}
        }
    },
    grid: {
        left: 0,
        right: 0,
        containLabel: true,
    },
    xAxis: {
        type: 'time',
        @* type: 'category', *@
        boundaryGap: false,
    },
    yAxis: {
        type: 'value',
        axisLabel: {
            formatter: function(params){
                //let label = params.value[1]; // this is my y column
                let label = params;
                return label.toLocaleString();
            },
            showMinLabel: false
        },
        min: function(value) {
            if (value.min < 0) {
                return value.min;
            }
            let d = (value.max - value.min);
            if (d < value.max * 0.2)
                d = value.max * 0.2;
            let v = value.min - d * 0.5;
            if (v < 0) {
                return 0;
            }
            return v;
        }

        @* boundaryGap: ['0%', '0%'] *@
         @*,
        min: 'dataMin',
        max: 'dataMax' *@
    },
    @* tooltip: {
        trigger: 'item',
        axisPointer: {
        type: 'shadow',
        },
        formatter: (params) => {
            return
                "TimeStamp: " + params[0].value[0].toLocaleString() + "<br>" +
                params[0].seriesName + ": " + params[0].value[1].toLocaleString() + "<br>";
        }
    }, *@
    @* tooltip: {
        valueFormatter: function(params){
            //let label = params.value[1]; // this is my y column
            let label = params;
            return label.toLocaleString();
        }
    }, *@
    dataZoom: [
        {
        type: 'inside',
        @* start: 95, *@
        startValue: zoomStart,
        endValue: zoomEnd
        },
        {
        @* start: 95, *@
        startValue: zoomStart,
        endValue: zoomEnd
        }
    ],
    series: [
        {
        name: 'Water (Liter)',
        type: 'line',
        @if (Model.ShowTimelineSlider) {
            @: symbol: 'none',
        } else {
            @: symbol: 'emptyCircle',
        }
        sampling: 'lttb',
        itemStyle: {
            color: '#37addd'
        },
        areaStyle: {
            color: '#37addd'
        },
        data: data2
        }
    ]
    };


    if (option && typeof option === 'object') {
    myChart.setOption(option);
    }

    window.addEventListener('resize', myChart.resize);
});
    </script>
}
